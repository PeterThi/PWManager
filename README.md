# PWManager

<h1> Part one</h1>

First the manager is going to require the user to sign up. I have chosen to do this using a Username and a MasterPassword, which the user has to input. This will create a user using the following flow:

![pwManagerCreate](https://github.com/PeterThi/PWManager/assets/60512162/1917a917-bd81-4ce1-83dd-11fcf8d4ad6a)

from this we get two keys: an Authentication Key and a Vault Key. The Authentication key is later used to authenticate the user, which is why it will be stored in a local database. The Vault Key will not be stored in the database, as that is a secret used to encrypt and decrypt passwords later.

After this, the user will have to log in to the application using their credentials again. The flow looks like this: 

![pwManagerLogin](https://github.com/PeterThi/PWManager/assets/60512162/8fa2caa5-126e-4765-8ed9-f21baa9ee101)

We go through the same steps as in the create function, so that we can derive a new AuthenticationKey. We will then compare the two authentication keys, and if they're a match, the user will be validated and logged in to the manager.

From here, the user will be able to manage their passwords. First of all, they will need to be able to create a new password in the system. This flow should look like this:

![pwManagerNewPassword](https://github.com/PeterThi/PWManager/assets/60512162/b74b3da4-9b8b-4af3-a4bc-0ccb5aea5a24)

In this flow we will generate a string of a set length using random letters and numbers - preferably mixing upper and lower case. This string is then encrypted using the derived VaultKey from the credentials, and stored encrypted in the database. When creating a password, the user can input the name of the website that the password is gonna correspond with for a better user experience. I have chosen not to include usernames or e-mails in this as a last resort if this manager should be compromised in some way. 

Finally, the manager must show the user their passwords with their corresponding websites in a list-like display (when logged in of course). Flow:

![pwManagerViewPasswords](https://github.com/PeterThi/PWManager/assets/60512162/c170198e-bc89-4bce-98a9-6c62b224f3f9)

if the user is logged in, we will gather all encrypted passwords from the database. Here the manager will decrypt them all using the derived vault key from earlier. The application will then list all passwords in plain text together with their corresponding website-name for easy access. 

<h1> Part Two </h1>
<h1> Presentation of the product</h1>
The very simple GUI I've made is quite a bundled up mess, so I will present it bit by bit.

<h2> Create Master Password</h2>
The first thing a user will have to do, is to create a new masterpassword, that the user itself will have to remember. This password will open up the password manager.
This use case is handled through a simple textbox and button in the GUI:

![CreateMasterPass](https://github.com/PeterThi/PWManager/assets/60512162/8f1de266-5811-48a4-80bf-6eacd919c38e)

The button calls an eventhandler, which calls the manager's "createNewMasterPassword" function using the supplied text from the textbox.

<h2> Login </h2>
The login interface is very similar, with a button calling the "ValidateUser" function. To get access to your passwords, insert the same text from when you created your password

<h2> Show passwords </h2>
When logged in, your passwords will be shown to you in plain text. For added comfort, the plaintext is displayed in an unmodifiable textbox, which makes it possible to copy the password to the clipboard, so the user can paste it into their matching website when needed. 
Every password has a corresponding domain name, where the password is inteded to be used.

<h2> Create new password </h2>
Finally, the user is welcome to create a new password for any domain they want. The user may input a preferred length of the generated password to fit any restrictions the domain might have. If nothing is specified, it defaults to 16 characters.
All passwords are currently generated by the application, consisting of 3 randomly chosen english words, and possibly some numbers at the end. For simplicity, only a handful of words are in the selection pool, but in a real application, you would preferably use the full English dictionary or something similar. 


<h1> Security discussions</h1>
<h2> Security Model</h2>
I've taken several precautions to try to limit the impact of an attacker gaining unauthorized access to the local database. First of all, I've made sure the password is as difficult to derive as possible. When creating a masterpassword, two keys are derived: A "Vault key" and an encryption key. The encryption key is derived by using the industry standard pbkdf2 method on the masterpassword, with 1000 iterations. This number could probably benefit from being even higher, but the higher number of iterations should make it slower for any kind of brute force attack to derive the key. 
This key is used to encrypt and decrypt all the domain passwords. Passwords are stored in the database as their encrypted versions using AES (CBC). The encryption key, however, is never stored in the database, which should make it more difficult for an attacker with access to the database to derive the plain text passwords. 
The vault key is used to authenticate the user's inputted masterpassword when trying to login. This key is created using the encryptionkey with AES (CBC). This key is saved in the database, together with the salt used in the creation of the Encryption key, and the IV from creating the vault key. To authenticate, the application takes the inputted master password, creates a new encryption key with the salt from the database and a vault key with the saved IV. The vault key is then compared to the vault key from the database. If this is the same, the user is authenticated. 
This means that an attack with access to the database would still need the encryption key in order to gain anything from their access to the encrypted passwords. 

With this application being strictly local, it would require an attacker to somehow have access to the computer. All it really takes to access all passwords, is the input of a single master password, so of course the application is still vulnerable to human errors like the classical mistake of leaving your computer open with a post-it on the side of your monitor showing your password in plain text. This is however a trade off, as so many other security implementations, which would sacrifice a lot of user experience to deal with. 
Another possible pitfall, is that the application, once logged in, will show you your passwords in plain text. This could easily be spotted by another human in the vicinity of the monitor, or spotted by any malware on the computer with access to your screen. This is however another trade-off with the user experience, because the whole point of the password manager is to show you your password. I'm sure, however, the passwords could be shown more subtlely than in my application.

