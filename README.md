# PWManager

<h1> Part Two </h1>

<h2> How to Run </h2>
The solution consists of two c# projects - one for business logic (PasswordManager) and the GUI. To run the program, simply run the GUI project. You will then need to create a new masterpassword following the steps below.

*NOTE*: The manager is set up to store values in a local MSSQL Server database, connected by a connectionstring. For values to be stored, and be able to be validated, you need to set up the connectionstring and database. 

<h1> Presentation of the product</h1>
For simplicity's sake, the GUI is made up of a single window, which makes it a little compact. For that reason, I'll present it bit by bit.

<h2> Create Master Password</h2>
The first thing a user will have to do, is to create a new masterpassword, that the user itself will have to remember. This password will open up the password manager.
This use case is handled through a simple textbox and button in the GUI:

![CreateMasterPass](https://github.com/PeterThi/PWManager/assets/60512162/8f1de266-5811-48a4-80bf-6eacd919c38e)

The button calls an eventhandler, which calls the manager's "createNewMasterPassword" function using the supplied text from the textbox. The following flow is outlined on this model:

![NEWMasterPassword](https://github.com/PeterThi/PWManager/assets/60512162/3aecd384-57b2-428d-87b2-774a4bd6bfbc)


<h2> Login </h2>
The login interface is very similar, with a button calling the "ValidateUser" function. To get access to your passwords, the user must insert the same text from when you created your password

![Login](https://github.com/PeterThi/PWManager/assets/60512162/d2f0cfa5-ceca-4dc7-8666-5c6a4325a0b9)

The flow looks like this:

![NEWLogin](https://github.com/PeterThi/PWManager/assets/60512162/e8f98722-bd4c-41e1-91f3-787d6fc4b40d)

<h2> Show passwords </h2>
When logged in, your passwords will be shown to you in plain text. For added comfort, the plaintext is displayed in an unmodifiable textbox, which makes it possible to copy the password to the clipboard, so the user can paste it into their matching website when needed. 
Every password has a corresponding domain name, where the password is inteded to be used.

![password](https://github.com/PeterThi/PWManager/assets/60512162/95ac0db9-6294-44a8-963e-3a8c486a0c12)

Flow:

![NEWVIewPassword](https://github.com/PeterThi/PWManager/assets/60512162/053d219c-c3ef-435b-b915-720c29ead21c)


<h2> Create new password </h2>
Finally, the user is welcome to create a new password for any domain they want. The user may input a preferred length of the generated password to fit any restrictions the domain might have. If nothing is specified, it defaults to 16 characters.
All passwords are currently generated by the application, consisting of 3 randomly chosen english words, and possibly some numbers at the end. For simplicity, only a handful of words are in the selection pool, but in a real application, you would preferably use the full English dictionary or something similar. 

![createWebsitePass](https://github.com/PeterThi/PWManager/assets/60512162/61f33db3-318e-4fc1-b036-8af91410e91f)

![NEWWebsitePassword](https://github.com/PeterThi/PWManager/assets/60512162/352e7d3b-1266-4262-a12d-f2df4ca9d7b1)


The full WPF page looks like this:
![Full](https://github.com/PeterThi/PWManager/assets/60512162/6fa71f34-e229-4698-a3f3-e5edea97907e)


<h1> Security discussions</h1>
<h2> Security Model and Threat Actors</h2>
I've taken several precautions to try to limit the impact of an attacker gaining unauthorized access to the local database. First of all, I've made sure the password is as difficult to derive as possible. When creating a masterpassword, two keys are derived: A "Vault key" and an encryption key. The encryption key is derived by using the industry standard pbkdf2 method on the masterpassword, with 1000 iterations. This number could probably benefit from being even higher, but the higher number of iterations should make it slower for any kind of brute force / dictionary attack to derive the key. 
This key is used to encrypt and decrypt all the domain passwords. Passwords are stored in the database as their encrypted versions using AES (CBC). The encryption key, however, is never stored in the database, which should make it more difficult for an attacker with access to the database to derive the plain text passwords. 
The vault key is used to authenticate the user's inputted masterpassword when trying to login. This key is created using the encryptionkey with AES (CBC). This key is saved in the database, together with the salt used in the creation of the Encryption key, and the IV from creating the vault key. To authenticate, the application takes the inputted master password, creates a new encryption key with the salt from the database and a vault key with the saved IV. The vault key is then compared to the vault key from the database. If this is the same, the user is authenticated. 
This means that an attacker with access to the database would still need the encryption key in order to gain anything from their access to the encrypted passwords. This application uses an MSSQL server as the database management system, which could provide an additional layer of security by encrypting this database. Only the default security settings are used in this project though. 
<br>
The website passwords are actually more a passphrase than a password. The thought behind this is that passphrases are often easier to remember, while also being longer, making it costlier for brute force attacks. You could argue, however, that when you're using a password manager, the user does not want something rememberable, as it is written down anyway. 

<h2> Pitfalls</h2>
With this application being strictly local, it would require an attacker to somehow have access to the computer. All it really takes to access all passwords, is the input of a single master password, so of course the application is still vulnerable to human errors (social engineering) or the likes of the classical mistake of leaving your computer open with a post-it on the side of your monitor showing your password in plain text. This is however a trade off, as so many other security implementations, which would sacrifice a lot of user experience to deal with. This will in turn protect against keyloggers or similar types of malware that records input - because you can only log on from this device. Being local means that the application does not need to worry about the communication channel between the database and the application either, where as communication between a cloud-based password manager and the user could be intercepted by a man in the middle - attack.
There are of course downsides to being local as well. For example, it only works on one device, and if you lose access to the device, there is no way to recover your passwords. 
Another possible pitfall, is that the application, once logged in, will show you ALL your passwords in plain text. This could easily be spotted by another human in the vicinity of the monitor, or spotted by any malware on the computer with access to your screen. This is however another trade-off with the user experience, because the whole point of the password manager is to show you your password. I'm sure, however, the passwords could be shown more subtlely than in my application - like only showing one at a time, or copying it straight to your clipboard without showing it.
<br>
The generated passwords are at the moment a huge pitfall as well, by only having a handful of words to generate the passwords from. The dream scenario would feature more words with a mix of capital letters and numbers inbetween - eventhough this would decrease the rememberability of the passwords. 
The master password itself is a major pitfall as well, due to lack of restrictions. The masterpassword could in theory be a single character, which is definitely not advised. 
<br>
Another potential risk is that I opted to keep the encryption key stored in a variable on the Passwordmanager instance, so the system did not have to generate it from scratch (which means saving the plain text master password somewhere), or fetch it from the database constantly. I imagine this being a security issue if this variable can somehow be obtained by an attacker, if it somehow has access to the machine's memory. 
